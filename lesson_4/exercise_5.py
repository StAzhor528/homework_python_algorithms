"""
Задание 5.**
Приведен наивный алгоритм нахождения i-го по счёту
простого числа (через перебор делителей).
Попробуйте решить эту же задачу,
применив алгоритм "Решето Эратосфена" (в материалах есть его описание)
Подсказка:
Сравните алгоритмы по времени на разных порядковых номерах чисел:
10, 100, 1000
Опишите результаты, сделайте выводы, где и какой алгоритм эффективнее
"""
from timeit import timeit


def simple(i):
    """Без использования «Решета Эратосфена»"""
    count = 1
    n = 2
    while count <= i:
        t = 1
        is_simple = True
        while t <= n:
            if n % t == 0 and t != 1 and t != n:
                is_simple = False
                break
            t += 1
        if is_simple:
            if count == i:
                break
            count += 1
        n += 1
    return n


def eratosthenes(k):
    """C использованием «Решета Эратосфена»"""
    b = []
    n = 3
    while len(b) != k:
        a = [0] * n
        for i in range(n):
            a[i] = i
        a[1] = 0
        m = 2
        while m < n:
            if a[m] != 0:
                j = m * 2
                while j < n:
                    a[j] = 0
                    j = j + m
            m += 1
        b = []
        for i in a:
            if a[i] != 0:
                b.append(a[i])
        del a
        n += 1
    return b[-1]


i = int(input('Введите порядковый номер искомого простого числа: '))
print('Искомое простое число: ', simple(i))
print('Время выполнения функции без использования Решета Эратосфена: ',
      timeit("simple(i)", "from __main__ import simple, i", number=1))
print('Искомое простое число: ', eratosthenes(i))
print('Время выполнения функции с использованием Решета Эратосфена: ',
      timeit("eratosthenes(i)", "from __main__ import eratosthenes, i", number=1))

# В случае применения алгоритма с Решетом Эратосфена необходимо для каждого порядкового номера до искомого
# создавать список из которого исключать все не простые числа. И пока длинна этого списка не станет равной
# введенному значению цикл не завершится.
# В случае нахождения i-го по счёту простого числа через перебор делителей производится простое арифметическое действие.
# И если результат действия не удовлетворяет условиям, то идем дальше.
# Вывод: наивный алгоритм быстрее чем решето.
